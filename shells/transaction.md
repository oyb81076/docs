# 分布式事务
## 几个理论
### ACID
事务原则
* a atomic 原子性,事务内容不可在分割
* c consistency 一致性,要么所有操作都成功,要么所有操作都失败
* i isolation 隔离性,不通事务之间是互不影响的
* d durability 持久性,程序崩溃的时候,已经提交的事务不受影响

### CAP
在分布式系统的设计中，没有一种设计可以同时满足一致性，可用性，分区容错性 3个特性
* c consistency 一致性
		all nodes see the same data at the same time
		更新操作成功并返回客户端完成后,分布式的所有节点在同一时间的数据完全一致
* a avaliblilty 可用性
		Reads and writes always succeed.
		读和写操作都能成功
		如强一致性的事务会需要加上各种拍他锁而导致读写总是被阻塞,甚至是死锁
* p partation tolerance 分区容忍性
		the system continues to operate despite arbitrary message loss or failure of part of the system
		在出现网络故障导致分布式节点间不能通信时，系统能否继续服务

### BASE
* BA basically avalible
		基本可用
* S soft state
		软状态
* E Eventual Consistency 
		最终一致性


* xa/jta acid 强一致性事务

# 通信问题
两阶段提交,保证是原子性,减小了通信问题带来的风险
通信问题一直是个蛋疼的问题,在此决定忽略通信问题,默认假设通信要么一直都是通的,要么一直都是不通的

## 关于spring分布式事务的想法
* 假设在一个跨点事务中,通信问题不存在(即要么一开始就不通,要么一直都是通的,不存在中途出现通信中断的问题)
* 严禁跨站点事务
* 采用多事务的方式避开单事务多数据源操作
* 单站点完整事务
* 数据在经过一定时间之后会变得准确
* 在业务中尽可能的不要读

### 应用场景(假定不存在通信问题)
#### 本地读,远程站点读写
极其简单,本地不需要事务,rpc调用的时候远程站点保证他的一致性就可以了
#### 本地写,远程站点读
先调用远程站点的数据,然后再在申明式事务中完成写
#### 本地读写,远程站点读
先在远程站点读取数据,本地站点读取数据,然后再在声明式事务中完成写
或者远程读取,本地声明式事务中读写
#### 本地写,远程写
复杂一点,要看主次,
如果远程为主,先请求远程服务,再保存本地数据
如果本地为主,直接调用本地,然后远程数据采用补偿机制

### 各安全级别下的数据操作方式
直接调用




该场景下,服务需要用rpc获取远程数据,操作本地数据.
如:如用户购物车和订单分布在两个站点上
那么一个完整的事务内容是
* 订单站点读取购物车站点内容
* 订单站点根据读取的数据生成订单
* 清空购物车站点数据

在这个场景下,生成订单是核心事务
在强一致性情况下,将以上事务拆分

#### 方案一,弱一致性
* 订单站点读取购物车站点内容的同时购物车站点设置购物车为待删除状态
* 创建订单
* 请求购物车站点清理待删除状态数据

在这个方案中,待删除状态有个失效时间,
如果购物车站点在一定时间内没有收到恢复或删除的请求,那么就自动恢复状态,变为可用状态

如果第一步中因为通信问题而出错,那么等待一定时间后,购物车站点会自动恢复正常
如果第二部出错,那么订单站点会发送一个恢复购物车的请求给购物车,如果没能够成功发送信息,等待一定时间后数据也会恢复正常
如果第三步出错,那么购物车数据就一直存在了






### 单数据源事务跨站点调用原则
* 在一个声明式事务内部,只允许单一数据源
* 跨站点事务情况下,禁止在声明式事务中使用rpc调用,所有数据请请,数据检查都要在事务之外准备好






# jta事务管理心得
## spring 下事务处理的默认原则
### @Transactional 注解
#### readonly
* [true|false]
* 是否是只读事务,这个实际上从数据库日志上看并没有意义,数据库还是会用用set autocommit=0来关闭自动提交,直到commit的时候
* readonly 只是针对当前事务的设置

### propagation 事务传播类型
* REQUIRED			需要	:需要事务,如果没有事务就创建事务
* SUPPORTS			支持	:支持已经存在的事务,如果存在事务,就运行在当前事务下,如果不存在的话,就以非事务模式运行
* MANDATORY			强制	:必须运行在一个已经开启的事务中
* REQUIRES_NEW	新建	:需要新事物,挂起当前事务,运行一个新的事务
* NOT_SUPPORTE	不支持:不支持事务,如果已经存在事务,就把当前事务暂停
* NEVER					否定	:不允许运行在事务环境中,如果存在事务就...
* NESTED				嵌套	:忘了他吧

**特别注意**
* EQUIRES_NEW,NOT_SUPPORTE
	这两个存在需要挂起当前事务的,实际上对数据库的操作是临时切换数据库连接池
* SUPPORTS 这个级别是比较优秀的,可以把事务打开的时间向后推迟,同时支持当前事务
* 慎用REQUIRES_NEW和NOT_SUPPORTE,这两个是和当前事务隔离开来的,
	如果事务隔离级别是READ_COMMITTED,那么就能读取到子事务中的数据,
	如果是REPEATABLE_READ,那么一旦在当前事务中使用过一次select,那么再一次读取的时候也是无法读取到此事务之外的数据的
	简单的说就是,当前事务读不到这个新开的事务的
**推荐配置**
* 不需要事务的地方就别弄事务了,读的方法使用support,这样有时候就可以避免开启事务来占用资源

### 事务隔离级别
* for update 是一个行级锁,锁住后会阻塞其他线程的写入操作,直到commit;

# 分布式事务的非分布式处理
## 补偿机制
一个db资源和一个mq资源
正常情况下要在一个原子事务中使用两个资源,要通过tx/xa协议来实现
使用补偿机制就是
* db资源写入(一个完整事务)
* mq资源写入(非事务形式写入)
*	mq写入失败的时候就对db资源进行反向操作

## 可靠补偿机制
在不可靠的补偿机制中,如果mq写入失败,则进行db资源的反向操作,
但是如果却无法保证反向操作一定成功,
可靠补偿就是对反向操作的一个保证,使反向操作可以被发现并重复尝试

